Go 
 Wprowadzenie do Go i praktyczny przegląd języka 

Krzysztof Jaśkiewicz
Piotr Przybylak

* Agenda
- Korzenie Go
- Przegląd elementów języka

.background images/lama_wallpaper.png

* Skąd wzięło się Go
Język Go powstał w 2009 w Google.
Jego autorami byli:

- Robert Griesemer
- Rob Pike
- Ken Thompson

Później dołączyli:

- Russ Cox
- Ian Lance Taylor

Wersja 1.0 została wydana w 2012 roku
.background images/clean_wallpaper.jpg

* Dlaczego powstało Go

Autorzy twierdzą, że wymyślili język Go czekając aż skompiluje się kod serwera nad którym pracowali ;)

.background images/clean_wallpaper.jpg

Google posiada:

- Olbrzymią ilość kodu w Javie i C++
- Rozwijanego przez olbrzymią ilość programistów
- Uruchamianego na olbrzymiej ilości serwerów

* Problemy Google

Istniejące narzędzia nie były budowane z myślą dużych, rozproszonych systemach

- za wolno działają
- za wolno sie kompilują
- zbyt skomplikowane

.background images/clean_wallpaper.jpg

* Problemy Google c.d.

.image images/go_w_google_zaznaczenie.png _ 970

* Założenia projektu Go
"What is the purpose of the project?"
"We believe it's worth trying again with a new language, a concurrent, garbage-collected language with fast compilation."

- wydajne działanie
- wydajna kompilacja
- łatwość użycia
- kod kompilowany do natywnej binarki
- garbage collection
- concurrency

.background images/clean_wallpaper.jpg


* Hello World!
.play hello2.go
.background images/slide_wallpaper.jpg

* Elementy Go
.background images/clean_wallpaper.jpg

* pakiety, importy
- każdy program Go składa się z pakietów
- żeby użyć publicznych elementów innego pakietu trzeba pakiet zaimportować
- elementy publiczne to te pisane wielką literą !!!
.play -edit example.go
.background images/clean_wallpaper.jpg

* Zmienne podstawowe:
- bool
- string
- int  int8  int16  int32  int64
- uint uint8 uint16 uint32 uint64 uintptr
- byte // alias for uint8
- rune // alias for int32, represents a Unicode code point
- float32 float64
- complex64 complex128
.background images/clean_wallpaper.jpg

* Zmienne podstawowe c.d.:
Zero values
Variables declared without an explicit initial value are given their zero value.

The zero value is:

0 for numeric types,
false for the boolean type, and
"" (the empty string) for strings.
.play zero.go

* Pętla
    sum := 0
    for i := 0; i < 10; i++ {
        sum += i
    }
`do/while` expressed as `for` loops.

`while(1)`

  for {
  	// loop forever
  }

`while(condition)`

  flag := false
  for !flag {
  	if flag {
    	flag = false
  	}
  }

* range
.play range.go
.background images/clean_wallpaper.jpg

* if
.play if.go
.background images/clean_wallpaper.jpg

* switch/case
.play switch.go
.background images/clean_wallpaper.jpg

* defer
.play defer.go
A defer statement defers the execution of a function until the surrounding function returns.
The deferred call's arguments are evaluated immediately, but the function call is not executed until the surrounding function returns.
.background images/clean_wallpaper.jpg

* Wskaźniki, ale bez arytmetyki
.play pointers.go
Unlike C, Go has no pointer arithmetic.
.background images/clean_wallpaper.jpg

* array, slice
  var a [10]int // array of ten integers
  b := make([]int, 0, 10)  // slice of 0 elements, 10 preallocated
  z := make([]int, 10)     // slice of 10 elements
  f := []int{1,2,3,4}
  fmt.Println(f[0], foo[2], foo[2:])  // 1 3 {3 4}
.background images/clean_wallpaper.jpg

* Mapy
  // map[string]int  - map of strings to ints
  f := map[string]int{
  	"foo": 1,
  	"bar": 2,
  }
  fmt.Println(f["foo"], foo["bar"])  // 1 2
.background images/clean_wallpaper.jpg

* Funkcje
.play -edit functions.go
.background images/clean_wallpaper.jpg

* Funkcje - wiele wartości zwracanych
.play -edit multiple-results.go
.background images/clean_wallpaper.jpg

* Funkcje też są wartościami
- funkcji można użyć jako argumentu funkcji
- funkcji można użyć jako wartości zwracanej przez funkcję
.play -edit function-values.go

* Closures
.play -edit function-closures.go
.background images/clean_wallpaper.jpg

* Struktury, metody i interfejsy - OOP w wydaniu Go
.background images/clean_wallpaper.jpg

* Struktury
.play struct.go /START OMIT/,/END OMIT/

: Structs can be embedded in other structs
: Can hide and show stuct fields
.background images/clean_wallpaper.jpg

* Metody
.play methods.go
.background images/clean_wallpaper.jpg

* Interfejsy
.play fooer.go /START OMIT/,/END OMIT/

: Interface implementations are implicit, that is the one who implements Fooer does not explicity mark that it does so
: There's no `implements`, `extends` or similar
.background images/clean_wallpaper.jpg

* Obsługa błędów
- Nie ma wyjątków; do obłsugi błędów wykorzystujemy wiele wartości zwracanych przez funkcje
- Funkcje często zwracają error, wołając funkcję powinniśmy sprawdzić czy error != nil
.play -edit error-handling.go
.background images/clean_wallpaper.jpg

* Łatwa współbieżność - goroutines
.play goroutines.go
.background images/clean_wallpaper.jpg

* Wbudowana obsługa standardów sieciowych
- HTTP
- gRPC
- JSON
- XML
.play -edit server.go

* Testy
.code test/foo.go
.code test/foo_test.go

* Testy c.d.
  $ go test -race
  $ go test -coverprofile coverage.out
  $ go tool cover -func=coverage.out
  $ go test  -bench .
.background images/clean_wallpaper.jpg

* Wygląda znajomo?
- Go nie ma ambicji być przełomowym językiem
- Jest za to w miarę nowym językiem
- C XXI wieku? = C + garbage collection + concurrency
.background images/clean_wallpaper.jpg

* Brak Generyków
Repeat this often

  func FindString(list []string, str string) bool {
  	for _, k := range list {
  		if k == str {
  			return true
  		}
  	}
  	return false
  }

  func FindInt(list []int, str int) bool {
  	for _, k := range list {
  		if k == str {
  			return true
  		}
  	}
  	return false
  }
.background images/clean_wallpaper.jpg

* Zarządzanie zależnościami

- aktualnie nie ma żadnego oficjalnego, gotowego rozwiązania

- zależności są trzymane w katalogu `vendor/` w projekcie

- problem długo dyskutowany przez społeczność Go - [[https://blog.gopheracademy.com/advent-2016/saga-go-dependency-management/][The Saga of Go Dependency Management]]

- dużo rozwiązań od community: govendor, glide, godep, glock, gvt
- Google stara się rozwiązać ten problem: vgo
- [[https://research.swtch.com/vgo-tour][https://research.swtch.com/vgo-tour]] spro jest już zrobione, ale na razie to tylko proposal
.background images/clean_wallpaper.jpg

* Zarządzanie zależnościami c.d.

  GOPATH=/home/user/gocode

  /home/user/gocode/
     src/
        github.com/
           bboozzoo/
              foo/
                 x.go    (go code in package github.com/bboozzoo/foo)
                 vendor/ (vendored dependencies)
                    golang.org/x/sys/unix/
                    github.com/sirupsen/logrus/
                    github.com/BurntSushi/toml/
.background images/clean_wallpaper.jpg

* Podsumowanie - cechy Go
- prostota
- wydajne działanie i kompilacja
- garbage collector
- concurrency
- wbudowana obsługa standardów sieciowych
- gotowe narzędzia (budowanie, testowanie, formatowanie)
- pedantyczność kompilatora (nieużywane importy, zmienne)
- jeden sposób formatowania kodu
- wspieranie wielu platform
.background images/clean_wallpaper.jpg
